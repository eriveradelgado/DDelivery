# ---------------------------------------------------------------------
#                          DDelivery
# ---------------------------------------------------------------------

# DDelivery is a working name that alludes to another package called DDsolver
# 

# These set of functions can be used to analyze release data from drug
# release experiments to better design drug delivery strategies using
# polymers as carriers. It is adapted to best handle data from 96 well plate
# format where the columns are integers from 1 to 12 and the rows are 
# letters from A to H. By using R and the tidyverse I hope to make the 
# analysis more transparent, accesible and reproducible for other scientists.
# The goal is to eventually adapt the equations summarized in Siepmann and 
# Siepmann 2008 to fit data from drug delivery and dissolution studies. A similar
# project to ddsolver in excel.

# Things to do (from EC2): 
# 1. Check differences between this version and the one in the lab
# 2. Fix 96 well plate import function
#    2.1 Use select instead of lapply
#    2.2 Choose a better name
#    2.3 Write tests to make sure the function works as it should
# 3. Fix get_time()
#    3.1 get time is not great
#    3.2 I don't know if it's a horrible function or our documentation
#        practices are cumbersome
#    3.3 Ask in stack exchange about proper practices in time tracking an 
#        experiment
# 4. Include a readme.MD
# 5. Reorganize recent delivery projects with a clear analysis workflow


# ---------------------------------------------------------------------
#                           File import
# ---------------------------------------------------------------------
# An in vitro delivery experiment involves one of two workflows. The scientist
# can freeze samples at the timepoints taken or the samples can be read immediately.
# Reading immediately may not always be possible if the number of samples is high
# because they may interfere with the next sampling interval.
# Independently of the workflow the scientist will end up with multiple files for each timepoin.
# In our case the  output of the h1 reader were excel files. The following workflow is a set of
# functions to rapidly extract rectangular data from the output generated by the 
# h1 reader.

# Current workflow 9 step process
## Annotate >> Import >> Join Import and Annotation file >> Extract the time 
## vector from the Import >> add other experimental metadata >> separate into
## experimental and calibration data >> calculate calibration parameters >>
## calculate drug release >> plot
# Multiple files with an established nomenclature in a single folder
# list the files in a folderlist.files(folder_path)
# import the files to R read_excel(lists_of_filepaths)
# convert to a tidy data based on the wells they occupied on the grid
# 

import_96wellplates <- function(filepath, pattern, remove = 0, skip = 16,  ...){
  require(readxl)
  require(dplyr)
  require(tidyr)
  filelist <- list.files(path       = filepath,
                         pattern    = pattern, 
                         full.names = T)
 # Sometimes theres files that make your life miserable;
 # remove takes care of them
   if(remove != 0){
    list.import <- lapply(filelist[-remove], read_excel, skip = skip,...)
    filelist <- filelist[-remove]
  }
  else{
    list.import <-  lapply(filelist, read_excel , skip= skip,...)
  }
  
well <- paste0(LETTERS[1:8], rep(1:12,each=8))

 # Binding all imported list and selecting the squareish data frame  
wide_df <-  list.import %>% 
  lapply(., '[',1:8 , 2:13) %>% 
  lapply(.,unlist) %>% 
  do.call(rbind, .) %>% 
  data.frame(filename = basename(filelist), .) 

names(wide_df) <- c("filename", well)
tidy_df <- gather(wide_df, key = "well", value = "absorbance", 2:97, -filename)
tidy_df[] <-lapply(tidy_df, function(x) if(is.factor(x)==T) as.character(x) else x) 
return(tidy_df)
}
# ---------------------------------------------------------------------
#                         Annotation
# ---------------------------------------------------------------------
wells <- function(initialrow, finalrow, initialcolumn, finalcolumn){
  # This function needs some constraints e.g. 13 column inputs or initial column
  # greater than finalcolumn. Besides most people don't write rows in number format
  wells <- paste0(rep(LETTERS[initialrow:finalrow], each = finalcolumn-initialcolumn+1),
                  rep(initialcolumn:finalcolumn, times = finalrow-initialrow+1))
  return(wells)
}

multi_join <- function(..., by){
# better name?
  jointhis <- list(...) 
  joint_df <- Reduce(function(x,y) merge(x,y, by = by),jointhis)

  return(joint_df)}

get_time <- function(raw.data, pattern = "(?<=D)[0-9]+"){
library(tidyr)
library(dplyr)
library(stringr)
library(gtools)

# get_time takes a raw.data output from import_96wellplates
# extract the filenames and turns the filename into numeric
# with a dayplate column it determines to which day each well 
# corresponds in a file
# dayplate is a dataframe with a column of values and a column of wells
raw.data <- raw.data[mixedorder(raw.data$well), ]

timelist <- raw.data$filename %>%
  str_extract_all(., pattern = pattern) %>% 
  lapply(., as.numeric)

raw.data <- mutate(raw.data, TID = 1:nrow(raw.data))

timetest <- vector("list", length = nrow(raw.data))

for(i in 1:nrow(raw.data)){
  timetest[[i]] <-timelist[[i]][raw.data$dayplate[i]]
}

df_time <- raw.data %>% 
  data.frame(., time = as.numeric(unlist(timetest)), stringsAsFactors = F) 

return(df_time)
}

annotate_plate <- function(wellgrid, values, varname){
  library(tidyr)
  library(stringr)
  library(dplyr)
  
  # This function allows you to annotate 96 well plates in a more readable fashion
  # wellgrid is a character rectangular grid of the kind A1:H12
  # more than one well grid can be supplied in a given character
  # ie. wellgrid = "A1:B3, A3:B6", value = 1
  # value is the iterated value for that grid
  # the vector length of value and wellgrid must be the same
  # ie. wellgrid = c("A3:B6, A4:B10", "E7:H7"), value = c(1,2)
  
  # values/variables need better names
  
  stringvector <- wellgrid %>% 
    str_extract_all(., pattern = "[A-Ha-h][0-9]+\\:[A-Ha-h][0-9]+")
  
  # ULQ stands for Upper Left Quadrant  (Top left)
  ULQ <- stringvector %>% 
    str_extract_all(., pattern = "(?<!\\:)[a-hA-H][0-9]+") # Negative lookbehind
  
  
  # LRQ stands for Lower Right Quadrant (Bottom Right)
  LRQ <- stringvector %>% 
    str_extract_all(., pattern = "(?<=[0-9]\\:)[a-hA-H][0-9]+") # ?<= lookbehind assertion
  
  initialrow <- ULQ %>% 
    str_extract_all(., pattern = "[A-H]" ) %>% 
    lapply(., match, table = LETTERS) 
  
  
  finalrow <- LRQ %>% 
    str_extract_all(., pattern = "[A-H]") %>% 
    lapply(., match, table = LETTERS)  
  
  initialcolumn <- ULQ %>%
    str_extract_all(., pattern = "[0-9]+") %>% 
    lapply(., as.numeric) 
  
  finalcolumn <- LRQ %>% 
    str_extract_all(., pattern = "[0-9]+") %>% 
    lapply(., as.numeric) 
  
  # Initializing values
  listtest <- vector("list", length(wellgrid))
  value <- vector("list", length(wellgrid))
 
   plate_96wells <- wells(initialrow = 1,
                         finalrow = 8, 
                         initialcolumn = 1,
                         finalcolumn = 12) %>%
    data.frame(well = ., stringsAsFactors = F)
  
  for(i in 1:length(wellgrid)){
    listtest[[i]] <- Map(wells, initialrow[[i]], finalrow[[i]], initialcolumn[[i]], finalcolumn[[i]])
    value[[i]] <- rep(values[i], length(unlist(listtest[[i]])))
  }
  
  df <- data.frame(well = unlist(listtest),
                   values = unlist(value),
                   stringsAsFactors = F) 
  
  annotated_df<- full_join(df, plate_96wells, by = "well")
  names(annotated_df)[2] <- varname
  return(annotated_df)
}

# ---------------------------------------------------------------------
#                         Calculations
# ---------------------------------------------------------------------

standard_curve <- function(df){ 
  library(dplyr)
  library(broom)
  
  b.m  <- df %>%
    do(model = lm(absorbance~concentration, data = .)) %>% 
    broom::tidy(model) %>%
    select(1:3) %>% 
    spread(key = term, estimate)

  r.sq <- df %>%
    do(model = lm(absorbance~concentration, data = .)) %>%
    glance(model) %>% 
    select(1:2)
  
  sc <- inner_join(b.m, r.sq, by = "caltime")
  names(sc) <- c("caltime", "intercept", "slope", "r.squared")
  return(sc)
}

dydx <- function(y,x){
  dydx <- (y-lag(y))/(x-lag(x))
  return(dydx)
}

mass_conservation <- function(cumulative.release, timepoint.release) {
  index <- timepoint.release<0
  sumindex <- sum(index)
  
  while(isTRUE(sumindex > 0)){
    index <- timepoint.release<0
    leadindex <- lead(index,default = F)
    cumulative.release[index] <- cumulative.release[leadindex]
    cumulative.release <- cumulative.release-lag(cumulative.release,default = 0) 
    sumindex <- sum(index)
  }
  return(cumulative.release)
}



drug_release <- function(df, intercept, slope, vial.volume, sample.volume){
  library(dplyr)
  # df is a data.frame with filename, wellname/SID, and absorbance/96wellouput
  # slope, vial.volume and sample.volume must be dimensionally correct (have the same units)

  release_df <- df %>%
    mutate(concentration = (absorbance - intercept)/slope) %>%
    mutate(drug.in.vial = concentration*vial.volume) %>%
    mutate(drug.removed = concentration*sample.volume) %>%
    mutate(total.removed = cumsum(drug.removed)) %>%         
    mutate(cumulative.release = drug.in.vial + total.removed - drug.removed) %>%
    mutate(timepoint.release = cumulative.release - lag(cumulative.release,default = F)) 
  return(release_df)}

